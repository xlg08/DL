"""
案例:
    演示张量的索引操作.

场景:
    简单行列索引
    列表索引
    范围索引
    布尔索引
    多维索引
"""
# 导包
import torch


def dm01():
    # 设置随机种子
    torch.manual_seed(24)
    # 1. 创建张量
    t1 = torch.randint(1, 10, (4, 5))
    print(f't1: {t1}')
    #  2. 演示: 简单行列索引
    print(t1[0, :])  # 第1行, 所有列
    print(t1[0])  # 效果同上, 语法糖.
    print(t1[2, 4])  # 第3行, 第5列
    print('-' * 24)
    # 3. 演示: 列表索引
    # 需求1: 返回(0, 1), (1, 2)两个位置的元素.
    #          行       列
    print(t1[[0, 1], [1, 2]])  # [9, 5]
    # 需求2: 返回(0, 3), (2,4)两个位置的元素.
    #          行       列
    print(t1[[0, 2], [3, 4]])  # [9, 5]
    # 需求3: 获取第0行和第2行的 第3列和第4列 共计: 4个元素.
    # (0, 3), (0, 4), (2, 3), (2, 4)
    #          行       列
    print(t1[[[0], [2]], [3, 4]])  # [9, 5]
    print(t1[:3:2, 3:5])  # 效果同上.
    print('-' * 24)
    # 4. 演示: 范围索引
    # 需求1: 前3行, 前2列
    print(t1[:3, :2])
    # 需求2: 第2行到最后, 前2列
    print(t1[1:, :2])
    print('-' * 24)
    # 5. 演示: 布尔索引
    # 需求1: 第3列 大于5的行数据.
    print(t1[:, 2] > 5)  # tensor([ True, False, False, False])
    print(t1[t1[:, 2] > 5])
    print(t1[torch.tensor([True, False, False, False])])  # 效果同上.
    # 需求2: 第2行 大于5的列数据.
    print(t1[:, t1[1] > 5])
    print(t1[1, t1[1] > 5])
    print('-' * 24)
    #  6. 演示: 多维索引
    t2 = torch.randint(1, 10, (3, 4, 5))
    print(f't2: {t2}')
    # 获取0轴上的第1个数据.
    print(t2[0, :, :])
    # 获取1轴上的第1个数据.
    print(t2[:, 0, :])
    # 获取2轴上的第1个数据.
    print(t2[:, :, 0])


def dm02():
    torch.manual_seed(24)

    t1 = torch.randint(1, 10, (4, 5))
    print(f"t1：", t1)

    # 简单行列索引
    print(f"t1的第一行，所有列：", t1[0, :])
    print(t1[0])  # 效果同上，语法糖格式
    print(f"第3行，第五列：", t1[2, 4])
    print('-' * 50)

    # 列表索引
    print(f'返回(0,1),(1,2)两个位置的元素：', t1[[0, 1], [1, 2]])
    # print(f'返回(0,1),(1,2)两个位置的元素：', t1[[0, 1], [1, 2]].view(-1))

    print(f'返回(0,3),(2,4)两个位置的元素：', t1[[0, 2], [3, 4]])  # 行
    print(f"返回第0， 2行，和第3，4 列的元素，共计4个元素：\n", t1[[[0], [2]], [3, 4]])
    print(f"：", t1[[[0], [2]], [[3], [4]]])  # 列

if __name__ == '__main__':
    dm01()